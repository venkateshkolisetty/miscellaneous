=head1 NAME

Gtk2::InfoBar

=cut

=head1 HIERARCHY

  Glib::Object
  +----Glib::InitiallyUnowned
       +----Gtk2::Object
            +----Gtk2::Widget
                 +----Gtk2::Container
                      +----Gtk2::Box
                           +----Gtk2::HBox
                                +----Gtk2::InfoBar



=cut

=head1 INTERFACES

  Glib::Object::_Unregistered::AtkImplementorIface
  Gtk2::Buildable
  Gtk2::Orientable



=cut


=head1 METHODS

=head2 $widget = Gtk2::InfoBar->B<new>;

=head2 $widget = Gtk2::InfoBar->B<new> (...)

=over

=item * ... (list) of button-text => response-id pairs.

=back


The multi-argument form takes the same list of text => response-id pairs as
C<< $infobar->add_buttons >>.  Do not pack widgets directly into the infobar;
add them to C<< $infobar->get_content_area () >>.

Here's a simple example:

 $infobar = Gtk2::InfoBar->new ('gtk-ok'     => 'accept',
                                'gtk-cancel' => 'reject');


=head2 $widget = Gtk2::InfoBar->B<new_with_buttons> (...)

=over

=item * ... (list) of button-text => response-id pairs.

=back


Alias for the multi-argument version of C<< Gtk2::InfoBar->new >>.


=head2 widget = $info_bar-E<gt>B<get_action_area> 

=head2 $info_bar-E<gt>B<add_action_widget> ($child, $response_id)

=over

=item * $child (Gtk2::Widget) 

=item * $response_id (Gtk2::ResponseType) 

=back



=head2 widget = $info_bar-E<gt>B<add_button> ($button_text, $response_id)

=over

=item * $button_text (string) 

=item * $response_id (scalar) 

=back

=head2 $info_bar-E<gt>B<add_buttons> (...)

=over

=item * ... (list) of button-text => response-id pairs

=back

Like calling C<< $infobar->add_button >> repeatedly, except you don't get the
created widgets back.  The buttons go from left to right, so the first button
added will be the left-most one.

=head2 widget = $info_bar-E<gt>B<get_content_area> 

=head2 $info_bar-E<gt>B<set_default_response> ($response_id)

=over

=item * $response_id (Gtk2::ResponseType) 

=back



=head2 messagetype = $info_bar-E<gt>B<get_message_type> 

=head2 $info_bar-E<gt>B<set_message_type> ($type)

=over

=item * $type (Gtk2::MessageType) 

=back

=head2 $info_bar-E<gt>B<response> ($response_id)

=over

=item * $response_id (Gtk2::ResponseType) 

=back



=head2 $info_bar-E<gt>B<set_response_sensitive> ($response_id, $setting)

=over

=item * $response_id (Gtk2::ResponseType) 

=item * $setting (boolean) 

=back

Enable or disable an action button by its I<$response_id>.



=cut


=head1 PROPERTIES

=over

=item 'message-type' (Gtk2::MessageType : default "info" : readable / writable / construct / private)

The type of message

=back



=cut


=head1 STYLE PROPERTIES

=over

=item 'action-area-border' (integer : default 5 : readable / private)

Width of border around the action area

=item 'button-spacing' (integer : default 6 : readable / private)

Spacing between buttons

=item 'content-area-border' (integer : default 8 : readable / private)

Width of border around the content area

=item 'content-area-spacing' (integer : default 16 : readable / private)

Spacing between elements of the area

=back



=cut


=head1 SIGNALS

=over

=item B<response> (Gtk2::InfoBar, integer)

=item B<close> (Gtk2::InfoBar)

=back



=cut

=for position post_signals

Note that currently in a Perl subclass of C<Gtk2::InfoBar> a class
closure, ie. class default signal handler, for the C<response> signal
will be called with the response ID just as an integer, it's not
turned into an enum string like C<"ok"> the way a handler setup with
C<signal_connect> receives.

Hopefully this will change in the future, so don't count on it.  In
the interim the easiest thing to do is install your default handler in
C<INIT_INSTANCE> with a C<signal_connect>.  (The subtleties of what
order handlers are called in will differ, but often that doesn't
matter.)

=cut




=head1 ENUMS AND FLAGS

=head2 enum Gtk2::MessageType

=over

=item * 'info' / 'GTK_MESSAGE_INFO'

=item * 'warning' / 'GTK_MESSAGE_WARNING'

=item * 'question' / 'GTK_MESSAGE_QUESTION'

=item * 'error' / 'GTK_MESSAGE_ERROR'

=item * 'other' / 'GTK_MESSAGE_OTHER'

=back


=head2 enum Gtk2::ResponseType


The response type is somewhat abnormal as far as gtk2-perl enums go.  In C,
this enum lists named, predefined integer values for a field that is other
composed of whatever integer values you like.  In Perl, we allow this to
be either one of the string constants listed here or any positive integer
value.  For example, 'ok', 'cancel', 4, and 42 are all valid response ids.
You cannot use arbitrary string values, they must be integers.  Be careful,
because unknown string values tend to be mapped to 0.


=over

=item * 'none' / 'GTK_RESPONSE_NONE'

=item * 'reject' / 'GTK_RESPONSE_REJECT'

=item * 'accept' / 'GTK_RESPONSE_ACCEPT'

=item * 'delete-event' / 'GTK_RESPONSE_DELETE_EVENT'

=item * 'ok' / 'GTK_RESPONSE_OK'

=item * 'cancel' / 'GTK_RESPONSE_CANCEL'

=item * 'close' / 'GTK_RESPONSE_CLOSE'

=item * 'yes' / 'GTK_RESPONSE_YES'

=item * 'no' / 'GTK_RESPONSE_NO'

=item * 'apply' / 'GTK_RESPONSE_APPLY'

=item * 'help' / 'GTK_RESPONSE_HELP'

=back




=cut


=head1 SEE ALSO

L<Gtk2>, L<Glib::Object>, L<Glib::InitiallyUnowned>, L<Gtk2::Object>, L<Gtk2::Widget>, L<Gtk2::Container>, L<Gtk2::Box>, L<Gtk2::HBox>


=cut


=head1 COPYRIGHT

Copyright (C) 2003-2011 by the gtk2-perl team.

This software is licensed under the LGPL.  See L<Gtk2> for a full notice.



=cut

