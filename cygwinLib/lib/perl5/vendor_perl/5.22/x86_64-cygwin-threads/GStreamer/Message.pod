=head1 NAME

GStreamer::Message

=cut

=for position DESCRIPTION

=head1 DESCRIPTION

The various nmessage types are represented as subclasses:

=over

=item GStreamer::Message::EOS

=item GStreamer::Message::Error

=item GStreamer::Message::Warning

=item GStreamer::Message::Info

=item GStreamer::Message::Tag

=item GStreamer::Message::Buffering

=item GStreamer::Message::StateChanged

=item GStreamer::Message::StateDirty

=item GStreamer::Message::StepDone

=item GStreamer::Message::ClockProvide

=item GStreamer::Message::ClockLost

=item GStreamer::Message::NewClock

=item GStreamer::Message::StructureChange

=item GStreamer::Message::StreamStatus

=item GStreamer::Message::Application

=item GStreamer::Message::Element

=item GStreamer::Message::SegmentStart

=item GStreamer::Message::SegmentDone

=item GStreamer::Message::Duration

=item GStreamer::Message::Latency [0.10.12]

=item GStreamer::Message::AsyncStart [0.10.13]

=item GStreamer::Message::AsyncDone [0.10.13]

=back

To create a new message, you call the constructor of the corresponding class.

To check if a message is of a certain type, use the I<&> operator on the
I<type> method:

  if ($message -> type & "error") {
    # ...
  }

  elsif ($message -> type & "eos") {
    # ...
  }

To get to the content of a message, call the corresponding accessor:

  if ($message -> type & "state-changed") {
    my $old_state = $message -> old_state;
    my $new_state = $message -> new_state;
    my $pending = $message -> pending;

    # ...
  }

  elsif ($message -> type & "segment-done") {
    my $format = $message -> format;
    my $position = $message -> position;

    # ...
  }

=cut




=head1 METHODS

=head2 object = $message-E<gt>B<src> 

=head2 structure = $message-E<gt>B<get_structure> 

=head2 64 bit unsigned = $message-E<gt>B<timestamp> 

=head2 messagetype = $message-E<gt>B<type> 



=cut


=head1 ENUMS AND FLAGS

=head2 flags GStreamer::MessageType

=over

=item * 'unknown' / 'GST_MESSAGE_UNKNOWN'

=item * 'eos' / 'GST_MESSAGE_EOS'

=item * 'error' / 'GST_MESSAGE_ERROR'

=item * 'warning' / 'GST_MESSAGE_WARNING'

=item * 'info' / 'GST_MESSAGE_INFO'

=item * 'tag' / 'GST_MESSAGE_TAG'

=item * 'buffering' / 'GST_MESSAGE_BUFFERING'

=item * 'state-changed' / 'GST_MESSAGE_STATE_CHANGED'

=item * 'state-dirty' / 'GST_MESSAGE_STATE_DIRTY'

=item * 'step-done' / 'GST_MESSAGE_STEP_DONE'

=item * 'clock-provide' / 'GST_MESSAGE_CLOCK_PROVIDE'

=item * 'clock-lost' / 'GST_MESSAGE_CLOCK_LOST'

=item * 'new-clock' / 'GST_MESSAGE_NEW_CLOCK'

=item * 'structure-change' / 'GST_MESSAGE_STRUCTURE_CHANGE'

=item * 'stream-status' / 'GST_MESSAGE_STREAM_STATUS'

=item * 'application' / 'GST_MESSAGE_APPLICATION'

=item * 'element' / 'GST_MESSAGE_ELEMENT'

=item * 'segment-start' / 'GST_MESSAGE_SEGMENT_START'

=item * 'segment-done' / 'GST_MESSAGE_SEGMENT_DONE'

=item * 'duration' / 'GST_MESSAGE_DURATION'

=item * 'latency' / 'GST_MESSAGE_LATENCY'

=item * 'async-start' / 'GST_MESSAGE_ASYNC_START'

=item * 'async-done' / 'GST_MESSAGE_ASYNC_DONE'

=item * 'request-state' / 'GST_MESSAGE_REQUEST_STATE'

=item * 'step-start' / 'GST_MESSAGE_STEP_START'

=item * 'qos' / 'GST_MESSAGE_QOS'

=item * 'progress' / 'GST_MESSAGE_PROGRESS'

=item * 'any' / 'GST_MESSAGE_ANY'

=back




=cut


=head1 SEE ALSO

L<GStreamer>


=cut


=head1 COPYRIGHT

Copyright (C) 2005-2014 by the gtk2-perl team.

This software is licensed under the LGPL.  See L<GStreamer> for a full notice.



=cut

